# RAG LLM Interface Service & File-Watcher Sidecar

## Overview
This project provides a local microservice and file-watcher sidecar for enhanced, context-aware LLM responses. It supports project/tag isolation, hybrid ingestion (full and incremental), robust API design, LLM routing, and is extensible for future multi-user or production scenarios.

## Key Features
- **REST API:** Versioned, OpenAPI-documented endpoints for ingestion, querying, admin, and health.
- **File-Watcher Sidecar:** Monitors file changes using Watchdog, batching and sending events to the API.
- **Hybrid Ingestion:** Supports both full project loads and incremental updates.
- **Project/Tag Isolation:** Uses EUIDs (ULID) for robust multi-project and tag support.
- **Vector Database:** SQLite with vector extension for local/solo use, abstracted for future migration.
- **LLM Routing:** Configurable routing to local (Ollama) or cloud (Gemini, etc.) LLMs, per-query or global.
- **Security & Observability:** Local-first defaults, with optional authentication, structured logging, and metrics.
- **Development Practices:** PEP8, type hints, literate docstrings, Sphinx docs, CI, and clear contribution guidelines.

## Documentation

This project uses Sphinx for literate, example-driven documentation. All modules and functions should have clear docstrings (Google or NumPy style preferred). To build the docs:

```sh
make docs
```

The main docs are in `docs/` and include:
- `index.rst`: Main entry point
- `usage.rst`: Quick start and workflow
- `api.rst`: API reference (autogenerated from docstrings)
- `design/file-watcher-sdd.md`: System design
- `adr/`: Architecture Decision Records

## Docstring Style

- Use Google or NumPy style docstrings for all public functions/classes.
- Include usage examples where possible.
- See `docs/api.rst` for how docstrings are rendered.

## Quick Start
1. Clone the repo and review the [SDD](docs/design/file-watcher-sdd.md).
2. Install dependencies (see Makefile or setup script).
3. Configure via YAML or environment variables.
4. Run the file-watcher sidecar and API service.
5. Use the OpenAPI docs or Swagger UI to explore the API.

## Development Environment & Dependency Management

This project uses [Poetry](https://python-poetry.org/) as the primary tool for dependency and environment management. All dependencies are declared in `pyproject.toml`.

- **Install Poetry:**
  ```bash
  curl -sSL https://install.python-poetry.org | python3 -
  # or see https://python-poetry.org/docs/#installation
  ```
- **Install dependencies:**
  ```bash
  poetry install
  ```
- **Activate the environment:**
  ```bash
  poetry shell
  ```
- **Editable install:** Poetry automatically installs the project in editable mode.
- **Run the API:**
  ```bash
  poetry run uvicorn ragms02.main:app --reload
  ```

## Testing

```bash
poetry run pytest
```

## Alternative: Conda Support

If you prefer conda, use `environment.yml` to create a base environment, then use Poetry for Python dependencies:

```bash
conda env create -f environment.yml
conda activate ragms02
poetry install
```

---

For full requirements, see the [SDD](docs/design/file-watcher-sdd.md) and [openapi.yaml](openapi.yaml).

## Features
- Chunked ingestion: File content is split into manageable chunks, each embedded and stored for granular retrieval.
- Improved retrieval: /query returns file path and snippet for each relevant chunk, providing context for LLM responses.
- **LangChain-powered RAG pipeline:** Uses LangChain for LLM-optimized chunking, retrieval, and context assembly.
- **LLM-optimized chunking:** File content is split using LangChain's RecursiveCharacterTextSplitter for better LLM compatibility.
- **Retrieval:** /query returns top relevant chunks as context for LLM responses.

## Developer Workflow

Use the provided `Makefile` for common development tasks:

```sh
make install      # Install all dependencies using Poetry
make dev          # Install dev dependencies and pre-commit hooks
make test         # Run all tests with pytest
make lint         # Run code linting with flake8
make format       # Format code with black
make run          # Run the FastAPI app (uvicorn)
make api          # Show OpenAPI docs (Swagger UI)
make docs         # Build Sphinx documentation
make clean        # Remove build/test artifacts
```

## LLM Provider Selection & API Key Configuration

This project supports routing queries to different LLM providers (e.g., Gemini, Ollama, OpenAI) via the LLM dispatcher. You can control which provider is used globally (via environment variable) or per-query (via the API `model`/`provider` field).

### Setting API Keys
- **Gemini (default):**
  - Set your API key as an environment variable:
    ```sh
    export GOOGLE_API_KEY=your-gemini-api-key
    ```
- **OpenAI:**
  - If you add OpenAI support, set:
    ```sh
    export OPENAI_API_KEY=your-openai-api-key
    ```
- **Ollama:**
  - Local models do not require an API key, but you can set the base URL with:
    ```sh
    export OLLAMA_BASE_URL=http://localhost:11434
    ```

### Changing Providers
- **Globally:** Set the default model/provider via environment variable:
  ```sh
  export RAGMS02_DEFAULT_MODEL=gemini-pro   # or 'openai-gpt-3.5-turbo', etc.
  ```
- **Per Query:** Pass the `model` or `provider` field in your API request to override the default for that request.

### Adding a New Provider
To add a new provider:
1. Implement a handler in `src/ragms02/llm/dispatcher.py` for the new provider.
2. Read the provider's API key from an environment variable (e.g., `OPENAI_API_KEY`).
3. Update the dispatcher to route requests to the new handler when selected.

See the SDD and code comments for more details.

## File Watcher Example

You can watch a directory for file changes using the built-in file watcher:

**Python script example:**
```python
from ragms02.watcher.watcher import WatcherConfig, FileWatcher

config = WatcherConfig(path="./my_project")
watcher = FileWatcher(config)
watcher.start()
```
Or run the watcher directly from the command line:
```bash
python src/ragms02/watcher/watcher.py
```
This will watch the current directory (`./`) for changes. Edit the script or pass a different path to `WatcherConfig` to watch another directory.

## Bulk Import / Recursive Directory Ingestion Example

You can bulk import all files from a directory (and its subdirectories) into a project using the API. This is useful for onboarding an entire codebase or document set.

**Python script example:**
```python
import os
import requests

API_URL = "http://localhost:8000/ingest/notify"
PROJECT_ID = "example-project"
ROOT_DIR = "./my_project"  # Change to your directory

events = []
for root, dirs, files in os.walk(ROOT_DIR):
    for file in files:
        rel_path = os.path.relpath(os.path.join(root, file), ROOT_DIR)
        events.append({"path": rel_path, "event_type": "created"})

payload = {
    "project_id": PROJECT_ID,
    "events": events
}

resp = requests.post(API_URL, json=payload)
print("Bulk ingest status:", resp.status_code)
print("Bulk ingest response:", resp.json())
```

**How it works:**
- Recursively walks `ROOT_DIR`, collecting all files.
- Sends a single `/ingest/notify` request with all file paths as events.
- The backend reads, chunks, embeds, and stores all files for the given project.

**Tip:** You can use this pattern to re-index or onboard any directory tree.

**Note:** The bulk import example requires the `requests` library. If you don't have it installed, add it to your environment with:
```bash
poetry add requests
# or
pip install requests
```

## Ignore Patterns for Ingestion and File Watching

This project supports robust, consistent file/directory exclusion for both the file watcher and bulk ingestion using a `.ragignore` file at the project root. The syntax is compatible with `.gitignore` and can be customized for your needs.

### How to Use

1. **Create/Edit `.ragignore`:**
   - Start by copying your `.gitignore` to `.ragignore`.
   - Add or remove patterns as needed (e.g., `examples/`, `*.log`).

2. **Bulk Ingestion:**
   - The `examples/bulk_ingest.py` script automatically loads `.ragignore` and skips ignored files/directories.

3. **File Watcher:**
   - The `examples/watch_with_ragignore.py` and `examples/watch_exclude_examples_dir.py` scripts both demonstrate using the same ignore logic for real-time event filtering, powered by `.ragignore`.

4. **Custom Patterns:**
   - Add any additional patterns to `.ragignore` to exclude them from both ingestion and watching.

### Example `.ragignore`

```
examples/
__pycache__/
*.log
*.tmp
```

### Implementation Details
- Ignore logic is implemented in `ignore_utils.py` (used by all watcher and ingestion scripts) using the `pathspec` library.
- All watcher and bulk ingest scripts import and use this utility for consistent behavior.
- The watcher will reload `.ragignore` on changes and emit delete events for files newly ignored.

**Note:** Install `pathspec` if needed:
```bash
poetry add pathspec
# or
pip install pathspec
```